use anyhow::Result;
use chrono::Utc;
use serde_json::{self, Value, json};

use crate::audit;
use crate::cli::commands::buckle_mode::BuckleModeState;
use crate::common::check_rotd_initialized;
use crate::fs_ops::*;
use crate::github;
use crate::pss;
use crate::schema::*;

// Helper function to fix common JSON errors
pub fn fix_common_json_errors(line: &str) -> String {
    let mut fixed = line.to_string();

    // Fix missing quotes around keys
    if let Ok(re) = regex::Regex::new(r"\{([^:]*):\s*") {
        fixed = re.replace_all(&fixed, "{\"$1\":").to_string();
    }

    // Fix missing comma between key-value pairs
    if let Ok(re) = regex::Regex::new(r#""([^"]+)"\s*:\s*"([^"]+)"\s+""#) {
        fixed = re.replace_all(&fixed, "\"$1\":\"$2\",\"").to_string();
    }

    // Fix trailing commas
    if let Ok(re) = regex::Regex::new(r",\s*}") {
        fixed = re.replace_all(&fixed, "}").to_string();
    }

    // Fix unquoted string values
    if let Ok(re) = regex::Regex::new(r":\s*([a-zA-Z_][a-zA-Z0-9_]*)\s*(,|\})") {
        fixed = re.replace_all(&fixed, ":\"$1\"$2").to_string();
    }

    fixed
}

pub fn init(force: bool, dry_run: bool) -> Result<()> {
    if dry_run {
        println!(
            "{{\"action\":\"init\",\"force\":{},\"dry_run\":true}}",
            force
        );
        return Ok(());
    }

    let rotd_dir = crate::common::rotd_path();

    if rotd_dir.exists() && !force {
        return Err(anyhow::anyhow!(
            "{{\"error\":\"rotd_exists\",\"message\":\".rotd directory exists. Use --force to overwrite.\"}}"
        ));
    }

    if rotd_dir.exists() && force {
        std::fs::remove_dir_all(&rotd_dir)?;
    }

    // Create directory structure
    std::fs::create_dir_all(&rotd_dir)?;
    std::fs::create_dir_all(crate::common::test_summaries_path())?;

    // Create initial files
    let initial_task = TaskEntry {
        id: "init".to_string(),
        title: "Initialize ROTD project".to_string(),
        status: TaskStatus::Complete,
        tests: None,
        description: None,
        summary_file: None,
        origin: None,
        phase: None,
        depends_on: None,
        priority: None,
        priority_score: None,
        created: Some(Utc::now()),
        updated_at: Some(Utc::now()),
        completed: Some(Utc::now()),
    };

    append_jsonl(&crate::common::tasks_path(), &initial_task)?;

    let session_state = SessionState {
        session_id: "init".to_string(),
        timestamp: Utc::now(),
        current_task: Some("init".to_string()),
        status: "initialized".to_string(),
        deltas: None,
    };

    write_json(&crate::common::session_state_path(), &session_state)?;

    let coverage_history = CoverageHistory {
        floor: 70.0,
        ratchet_threshold: 3.0,
        history: Vec::new(),
    };

    write_json(&crate::common::coverage_history_path(), &coverage_history)?;

    println!("{{\"status\":\"success\",\"action\":\"init\"}}");
    Ok(())
}

pub fn update_task(
    file: Option<&str>,
    strict: bool,
    pss: bool,
    timestamp: bool,
    dry_run: bool,
) -> Result<()> {
    check_rotd_initialized()?;

    let json_input = match file {
        Some(f) => std::fs::read_to_string(f)?,
        None => read_stdin()?,
    };

    let mut task: TaskEntry = serde_json::from_str(&json_input)
        .map_err(|e| anyhow::anyhow!("{{\"error\":\"invalid_json\",\"message\":\"{}\"}}", e))?;

    if strict {
        task.validate().map_err(|e| {
            anyhow::anyhow!("{{\"error\":\"validation_failed\",\"message\":\"{}\"}}", e)
        })?;
    }

    if timestamp {
        task.update_timestamp();
    }

    safe_update_task(&task, dry_run)?;

    if !dry_run {
        audit::log_info(
            Some(&task.id),
            "TASK_UPDATE",
            &format!("Task {} updated via agent", task.id),
        )?;
    }

    if pss && !dry_run {
        let score = pss::score_task(&task.id)?;
        pss::save_score(&score, false)?;
    }

    if !dry_run {
        println!(
            "{{\"status\":\"success\",\"action\":\"update_task\",\"task_id\":\"{}\"}}",
            task.id
        );
    }

    Ok(())
}

pub fn append_summary(file: &str, dry_run: bool) -> Result<()> {
    check_rotd_initialized()?;

    let summary: TestSummary = read_json(&std::path::Path::new(file))
        .map_err(|e| anyhow::anyhow!("{{\"error\":\"read_failed\",\"message\":\"{}\"}}", e))?;

    safe_append_summary(&summary, dry_run)?;

    if !dry_run {
        audit::log_info(
            Some(&summary.task_id),
            "SUMMARY_APPEND",
            &format!(
                "Test summary appended: {}/{} tests passed",
                summary.passed, summary.total_tests
            ),
        )?;

        println!(
            "{{\"status\":\"success\",\"action\":\"append_summary\",\"task_id\":\"{}\"}}",
            summary.task_id
        );
    }

    Ok(())
}

pub fn log_lesson(file: Option<&str>, dry_run: bool) -> Result<()> {
    check_rotd_initialized()?;

    let json_input = match file {
        Some(f) => std::fs::read_to_string(f)?,
        None => read_stdin()?,
    };

    let mut lesson: LessonLearned = serde_json::from_str(&json_input)
        .map_err(|e| anyhow::anyhow!("{{\"error\":\"invalid_json\",\"message\":\"{}\"}}", e))?;

    if lesson.timestamp.is_none() {
        lesson.timestamp = Some(Utc::now());
    }

    safe_log_lesson(&lesson, dry_run)?;

    if !dry_run {
        audit::log_info(
            None,
            "LESSON_LOGGED",
            &format!("Lesson logged: {}", lesson.id),
        )?;
        println!(
            "{{\"status\":\"success\",\"action\":\"log_lesson\",\"lesson_id\":\"{}\"}}",
            lesson.id
        );
    }

    Ok(())
}

pub fn ratchet_coverage(coverage: f64, task_id: Option<&str>, dry_run: bool) -> Result<()> {
    check_rotd_initialized()?;

    let mut coverage_history: CoverageHistory = read_json(&crate::common::coverage_history_path())
        .unwrap_or_else(|_| CoverageHistory {
            floor: 70.0,
            ratchet_threshold: 3.0,
            history: Vec::new(),
        });

    let triggered_ratchet = coverage > coverage_history.floor + coverage_history.ratchet_threshold;

    if triggered_ratchet {
        coverage_history.floor = coverage - 1.0; // Set new floor slightly below current
    }

    let entry = CoverageEntry {
        task_id: task_id.unwrap_or("unknown").to_string(),
        coverage,
        timestamp: Utc::now(),
        triggered_ratchet,
    };

    coverage_history.history.push(entry);

    if dry_run {
        println!(
            "{{\"action\":\"ratchet_coverage\",\"coverage\":{},\"triggered_ratchet\":{},\"new_floor\":{},\"dry_run\":true}}",
            coverage, triggered_ratchet, coverage_history.floor
        );
        return Ok(());
    }

    write_json(&crate::common::coverage_history_path(), &coverage_history)?;

    if triggered_ratchet {
        audit::log_info(
            task_id,
            "COVERAGE_RATCHET",
            &format!(
                "Coverage ratchet triggered: new floor {:.1}%",
                coverage_history.floor
            ),
        )?;
    }

    println!(
        "{{\"status\":\"success\",\"action\":\"ratchet_coverage\",\"coverage\":{},\"triggered_ratchet\":{},\"new_floor\":{}}}",
        coverage, triggered_ratchet, coverage_history.floor
    );

    Ok(())
}

pub fn score(task_id: &str, format: &str) -> Result<()> {
    check_rotd_initialized()?;

    let score = pss::score_task(task_id)?;

    match format {
        "json" => {
            println!("{}", serde_json::to_string(&score)?);
        }
        _ => {
            println!(
                "{{\"task_id\":\"{}\",\"score\":{},\"timestamp\":\"{}\"}}",
                score.task_id,
                score.score,
                score.timestamp.to_rfc3339()
            );
        }
    }

    Ok(())
}

pub fn check(fix: bool) -> Result<()> {
    check_rotd_initialized()?;

    let mut issues = Vec::new();
    let mut score = 0;
    let total_checks = 5;
    let mut fixed = Vec::new();

    // Check 1: Required files exist
    let required_files = [
        crate::common::tasks_path(),
        crate::common::session_state_path(),
        crate::common::coverage_history_path(),
    ];

    let files_exist = required_files.iter().all(|f| f.exists());
    if files_exist {
        score += 1;
    } else {
        issues.push("missing_required_files");
    }

    // Check 2: JSONL files are valid
    let jsonl_valid = read_jsonl::<TaskEntry>(&crate::common::tasks_path()).is_ok();
    if jsonl_valid {
        score += 1;
    } else {
        issues.push("invalid_jsonl");
    }

    // Check 3: Test summaries exist for completed tasks
    let tasks: Vec<TaskEntry> = read_jsonl(&crate::common::tasks_path()).unwrap_or_default();
    let completed_tasks: Vec<_> = tasks
        .iter()
        .filter(|t| matches!(t.status, TaskStatus::Complete))
        .collect();

    let summaries_complete = completed_tasks
        .iter()
        .all(|t| crate::common::test_summary_file(&t.id).exists());

    if summaries_complete {
        score += 1;
    } else {
        issues.push("missing_test_summaries");
    }

    // Check 4: No stubs remaining
    let no_stubs = !pss::check_stubs_remaining();
    if no_stubs {
        score += 1;
    } else {
        issues.push("stubs_remaining");
    }

    // Check 5: Session state is valid JSON
    let session_valid = read_json::<SessionState>(&crate::common::session_state_path()).is_ok();
    if session_valid {
        score += 1;
    } else {
        issues.push("invalid_session_state");
    }

    // Apply fixes if requested
    if fix && !issues.is_empty() {
        for issue in &issues {
            match *issue {
                "missing_required_files" => {
                    // Create missing files
                    for file_path in &required_files {
                        if !file_path.exists() {
                            match file_path.file_name().and_then(|f| f.to_str()) {
                                Some("session_state.json") => {
                                    let session_state = SessionState {
                                        session_id: "fix".to_string(),
                                        timestamp: chrono::Utc::now(),
                                        current_task: None,
                                        status: "initialized".to_string(),
                                        deltas: None,
                                    };
                                    if write_json(file_path, &session_state).is_ok() {
                                        fixed.push("created_session_state");
                                    }
                                }
                                Some("coverage_history.json") => {
                                    let coverage_history = CoverageHistory {
                                        floor: 70.0,
                                        ratchet_threshold: 3.0,
                                        history: Vec::new(),
                                    };
                                    if write_json(file_path, &coverage_history).is_ok() {
                                        fixed.push("created_coverage_history");
                                    }
                                }
                                Some("tasks.jsonl") => {
                                    // Create empty file
                                    if std::fs::File::create(file_path).is_ok() {
                                        fixed.push("created_tasks_file");
                                    }
                                }
                                _ => {}
                            }
                        }
                    }
                }
                "invalid_jsonl" => {
                    // Attempt to fix invalid JSON in tasks.jsonl
                    if let Ok(content) = std::fs::read_to_string(&crate::common::tasks_path()) {
                        let mut fixed_lines = Vec::new();
                        let mut has_errors = false;

                        for (line_num, line) in content.lines().enumerate() {
                            if line.trim().is_empty() {
                                continue;
                            }

                            // Try to parse and re-serialize to fix formatting issues
                            match serde_json::from_str::<serde_json::Value>(line) {
                                Ok(value) => {
                                    if let Ok(fixed_line) = serde_json::to_string(&value) {
                                        fixed_lines.push(fixed_line);
                                    } else {
                                        has_errors = true;
                                        fixed_lines.push(line.to_string());
                                    }
                                }
                                Err(_) => {
                                    // Try some basic fixes for common JSON errors
                                    let mut fixed = fix_common_json_errors(line);
                                    match serde_json::from_str::<serde_json::Value>(&fixed) {
                                        Ok(value) => {
                                            if let Ok(fixed_line) = serde_json::to_string(&value) {
                                                fixed_lines.push(fixed_line);
                                                fixed.push(
                                                    format!("fixed_json_line_{}", line_num + 1)
                                                        .chars()
                                                        .next()
                                                        .unwrap_or('_'),
                                                );
                                            } else {
                                                has_errors = true;
                                                fixed_lines.push(line.to_string());
                                            }
                                        }
                                        Err(_) => {
                                            has_errors = true;
                                            fixed_lines.push(line.to_string());
                                        }
                                    }
                                }
                            }
                        }

                        if !has_errors || fixed_lines.len() > 0 {
                            // Create a backup first
                            let backup_path = crate::common::rotd_path().join("tasks.jsonl.bak");
                            if std::fs::copy(&crate::common::tasks_path(), &backup_path).is_ok() {
                                // Write fixed content
                                if std::fs::write(
                                    &crate::common::tasks_path(),
                                    fixed_lines.join("\n"),
                                )
                                .is_ok()
                                {
                                    fixed.push("fixed_jsonl_format");
                                }
                            }
                        }
                    }
                }
                _ => {
                    // Other issues cannot be auto-fixed
                }
            }
        }
    }

    let health_percentage = (score as f64 / total_checks as f64) * 100.0;

    println!(
        "{{\"passed\":{},\"total_checks\":{},\"issues\":{:?},\"fixed\":{:?},\"health_percentage\":{:.1}}}",
        score, total_checks, issues, fixed, health_percentage
    );

    Ok(())
}

pub fn info() -> Result<()> {
    let info = serde_json::json!({
        "rotd_cli": {
            "version": "1.3.1",
            "agent_commands": {
                "update_task": {
                    "usage": "rotd agent update-task [--file FILE] [--strict] [--pss] [--timestamp]",
                    "input": "JSON task entry via stdin or file",
                    "purpose": "Update task in tasks.jsonl with validation"
                },
                "append_summary": {
                    "usage": "rotd agent append-summary --file FILE",
                    "input": "Test summary JSON file",
                    "purpose": "Add test results to test_summaries/"
                },
                "log_lesson": {
                    "usage": "rotd agent log-lesson [--file FILE]",
                    "input": "Lesson learned JSON via stdin or file",
                    "purpose": "Add lesson to lessons_learned.jsonl"
                },
                "ratchet_coverage": {
                    "usage": "rotd agent ratchet-coverage PERCENTAGE [--task-id ID]",
                    "input": "Coverage percentage (float)",
                    "purpose": "Update coverage floor if threshold exceeded"
                },
                "info": {
                    "usage": "rotd agent info",
                    "purpose": "Show this command reference"
                }
            },
            "coordination_commands": {
                "claim": {
                    "usage": "rotd coord claim [--capability CAP] [--skill-level LEVEL] [--any]",
                    "purpose": "Claim next available task by priority/capability",
                    "capabilities": ["frontend_ts", "backend_rust", "tests_only", "docs", "refactor"],
                    "skill_levels": ["entry", "intermediate", "expert"]
                },
                "release": {
                    "usage": "rotd coord release <task_id>",
                    "purpose": "Release claimed task and mark done"
                },
                "beat": {
                    "usage": "rotd coord beat",
                    "purpose": "Update agent heartbeat (required every 60s)"
                },
                "msg": {
                    "usage": "rotd coord msg \"message\"",
                    "purpose": "Log message to coordination.log"
                },
                "ls": {
                    "usage": "rotd coord ls [--verbose]",
                    "purpose": "List current work registry"
                },
                "quota": {
                    "usage": "rotd coord quota [--add TOKENS]",
                    "purpose": "View/update quota usage"
                },
                "clean-stale": {
                    "usage": "rotd coord clean-stale [--timeout SECS]",
                    "purpose": "Clean stale locks (default 15min timeout)"
                }
            },
            "multi_agent_setup": {
                "environment": {
                    "ROTD_AGENT_ID": "Required: unique agent identifier",
                    "ROTD_CAPABILITY": "Optional: primary capability filter",
                    "ROTD_SKILL_LEVEL": "Optional: skill level filter"
                },
                "workflow": [
                    "export ROTD_AGENT_ID=agent-backend",
                    "rotd coord beat",
                    "rotd coord claim --capability backend_rust",
                    "# work on task",
                    "rotd coord release <task_id>"
                ],
                "coordination_files": {
                    ".rotd/coordination/active_work_registry.json": "Task claim status",
                    ".rotd/coordination/coordination.log": "Agent communication",
                    ".rotd/coordination/quota.json": "Token usage tracking",
                    ".rotd/coordination/heartbeat/*.beat": "Agent liveness",
                    ".rotd/coordination/agent_locks/*": "Agent file locks"
                }
            },
            "global_flags": {
                "--agent": "Enable agent mode (minimal output, strict validation)",
                "--dry-run": "Show actions without executing",
                "--verbose": "Extended output (human mode only)"
            },
            "common_patterns": {
                "task_update": "echo '{\"id\":\"6.2\",\"status\":\"complete\"}' | rotd agent update-task --timestamp --pss",
                "test_complete": "rotd agent append-summary --file test_summaries/6.2.json",
                "log_failure": "echo '{\"id\":\"fix-001\",\"diagnosis\":\"...\",\"remediation\":\"...\"}' | rotd agent log-lesson",
                "multi_agent_start": "export ROTD_AGENT_ID=agent-1 && rotd coord beat && rotd coord claim",
                "multi_agent_finish": "rotd coord release <task_id> && rotd coord msg \"Task completed\""
            },
            "output_format": "JSON only in agent mode, human-readable tables in normal mode",
            "validation": "Strict schema enforcement with --strict flag, basic validation by default"
        }
    });

    println!("{}", serde_json::to_string_pretty(&info)?);
    Ok(())
}

// Update-related agent functions
pub fn update(check_only: bool, _skip_confirmation: bool) -> Result<()> {
    check_rotd_initialized()?;

    // Get current version
    let current_version = env!("CARGO_PKG_VERSION");

    // Check for updates
    let (update_available, latest_release) = match github::check_update() {
        Ok((available, release)) => (available, release),
        Err(e) => {
            let result = serde_json::json!({
                "action": "check_updates",
                "error": format!("Failed to fetch latest version: {}", e),
                "current_version": current_version,
                "latest_version": "unknown",
                "update_available": false
            });
            println!("{}", serde_json::to_string(&result)?);
            return Ok(());
        }
    };

    if check_only {
        if let Some(latest) = latest_release {
            // Extract changes from release description
            let changes = github::extract_changes(&latest.description);

            let result = serde_json::json!({
                "action": "check_updates",
                "current_version": current_version,
                "latest_version": latest.version,
                "update_available": update_available,
                "published_at": latest.published_at,
                "changes": changes,
                "download_url": latest.download_url,
                "html_url": latest.html_url
            });
            println!("{}", serde_json::to_string(&result)?);
        } else {
            let result = serde_json::json!({
                "action": "check_updates",
                "current_version": current_version,
                "update_available": false,
                "message": "No releases found"
            });
            println!("{}", serde_json::to_string(&result)?);
        }
        return Ok(());
    }

    // Check if update is available
    if !update_available {
        let result = serde_json::json!({
            "status": "success",
            "action": "update",
            "message": "No updates available",
            "current_version": current_version
        });
        println!("{}", serde_json::to_string(&result)?);
        return Ok(());
    }

    // Get latest release
    let latest =
        latest_release.ok_or_else(|| anyhow::anyhow!("No release information available"))?;

    // Create backup directory
    let rotd_dir = crate::common::rotd_path();
    let backup_dir = rotd_dir.join("backup");
    if backup_dir.exists() {
        std::fs::remove_dir_all(&backup_dir)?;
    }
    std::fs::create_dir_all(&backup_dir)?;

    // Backup existing files
    for file in ["tasks.jsonl", "session_state.json", "coverage_history.json"] {
        let src = rotd_dir.join(file);
        if src.exists() {
            std::fs::copy(&src, backup_dir.join(file))?;
        }
    }

    // Generate manifest
    let manifest = UpdateManifest {
        version: latest.version.clone(),
        date: latest.published_at.clone(),
        previous_version: current_version.to_string(),
        changes: vec![ChangeEntry {
            change_type: "feature".to_string(),
            component: "rotd".to_string(),
            description: latest.name.clone(),
            breaking: false,
            migration_required: false,
        }],
    };

    // Write manifest
    let manifest_path = rotd_dir.join("update_manifest.json");
    write_json(&manifest_path, &manifest)?;

    // Extract changes
    let changes = github::extract_changes(&latest.description);

    let result = serde_json::json!({
        "status": "success",
        "action": "update",
        "current_version": current_version,
        "new_version": latest.version,
        "changes": changes,
        "download_url": latest.download_url,
        "html_url": latest.html_url,
        "manifest_file": ".rotd/update_manifest.json"
    });

    println!("{}", serde_json::to_string(&result)?);
    Ok(())
}

pub fn upgrade(check_only: bool, _skip_confirmation: bool) -> Result<()> {
    // Get current binary version
    let current_version = env!("CARGO_PKG_VERSION");

    // Check for binary upgrades
    let (upgrade_available, latest_release) = match github::check_update() {
        Ok((available, release)) => (available, release),
        Err(e) => {
            let result = serde_json::json!({
                "action": "check_upgrades",
                "error": format!("Failed to fetch latest version: {}", e),
                "current_version": current_version,
                "latest_version": "unknown",
                "upgrade_available": false
            });
            println!("{}", serde_json::to_string(&result)?);
            return Ok(());
        }
    };

    if check_only {
        if let Some(latest) = latest_release {
            // Extract changes from release description
            let changes = github::extract_changes(&latest.description);

            let result = serde_json::json!({
                "action": "check_upgrades",
                "current_version": current_version,
                "latest_version": latest.version,
                "upgrade_available": upgrade_available,
                "published_at": latest.published_at,
                "changes": changes,
                "download_url": latest.download_url,
                "html_url": latest.html_url
            });
            println!("{}", serde_json::to_string(&result)?);
        } else {
            let result = serde_json::json!({
                "action": "check_upgrades",
                "current_version": current_version,
                "upgrade_available": false,
                "message": "No releases found"
            });
            println!("{}", serde_json::to_string(&result)?);
        }
        return Ok(());
    }

    // Check if upgrade is available
    if !upgrade_available {
        let result = serde_json::json!({
            "status": "success",
            "action": "upgrade",
            "message": "No upgrades available",
            "current_version": current_version
        });
        println!("{}", serde_json::to_string(&result)?);
        return Ok(());
    }

    // Get latest release
    let latest =
        latest_release.ok_or_else(|| anyhow::anyhow!("No release information available"))?;

    // Detect the current binary path
    let current_exe = std::env::current_exe()?;

    // Find the appropriate asset for the current platform
    let asset = match github::find_platform_asset(&latest) {
        Ok(asset) => asset,
        Err(e) => {
            let result = serde_json::json!({
                "status": "error",
                "action": "upgrade",
                "error": format!("No suitable binary found: {}", e),
                "current_version": current_version,
                "latest_version": latest.version
            });
            println!("{}", serde_json::to_string(&result)?);
            return Ok(());
        }
    };

    // Download the binary
    let binary_data = match github::download_binary(&asset.browser_download_url) {
        Ok(data) => data,
        Err(e) => {
            let result = serde_json::json!({
                "status": "error",
                "action": "upgrade",
                "error": format!("Download failed: {}", e),
                "current_version": current_version,
                "latest_version": latest.version
            });
            println!("{}", serde_json::to_string(&result)?);
            return Ok(());
        }
    };

    // Create temporary file for new binary
    let temp_path = current_exe.with_extension("new");
    if let Err(e) = std::fs::write(&temp_path, binary_data) {
        let result = serde_json::json!({
            "status": "error",
            "action": "upgrade",
            "error": format!("Failed to write binary: {}", e),
            "current_version": current_version,
            "latest_version": latest.version
        });
        println!("{}", serde_json::to_string(&result)?);
        return Ok(());
    }

    // Make it executable (Unix-like systems)
    #[cfg(unix)]
    {
        use std::os::unix::fs::PermissionsExt;
        if let Ok(metadata) = std::fs::metadata(&temp_path) {
            let mut perms = metadata.permissions();
            perms.set_mode(0o755);
            let _ = std::fs::set_permissions(&temp_path, perms);
        }
    }

    // Replace the current binary
    if let Err(e) = std::fs::rename(&temp_path, &current_exe) {
        let result = serde_json::json!({
            "status": "error",
            "action": "upgrade",
            "error": format!("Failed to install binary: {}", e),
            "current_version": current_version,
            "latest_version": latest.version
        });
        println!("{}", serde_json::to_string(&result)?);
        return Ok(());
    }

    // Extract changes
    let changes = github::extract_changes(&latest.description);

    let result = serde_json::json!({
        "status": "success",
        "action": "upgrade",
        "current_version": current_version,
        "new_version": latest.version,
        "changes": changes,
        "download_url": asset.browser_download_url
    });

    println!("{}", serde_json::to_string(&result)?);
    Ok(())
}

pub fn version(project: bool, latest: bool) -> Result<()> {
    if project {
        let version_path = crate::common::rotd_path().join("version.json");
        let version = if version_path.exists() {
            let v: ProjectVersion = read_json(&version_path)?;
            v.version
        } else {
            "1.3.1".to_string()
        };

        let result = serde_json::json!({
            "project_version": version,
            "tracked": version_path.exists()
        });
        println!("{}", serde_json::to_string(&result)?);
    } else if latest {
        // Check GitHub for latest version
        match github::fetch_latest_release()? {
            Some(latest) => {
                let result = serde_json::json!({
                    "latest_version": latest.version
                });
                println!("{}", serde_json::to_string(&result)?);
            }
            None => {
                let result = serde_json::json!({
                    "error": "Could not fetch latest version information",
                    "latest_version": "unknown"
                });
                println!("{}", serde_json::to_string(&result)?);
            }
        }
    } else {
        let version_path = crate::common::rotd_path().join("version.json");
        let project_version = if version_path.exists() {
            let v: ProjectVersion = read_json(&version_path)?;
            v.version
        } else {
            "1.3.1".to_string()
        };

        // Get latest version from GitHub
        let (update_available, latest_version) = match github::check_update() {
            Ok((available, Some(release))) => (available, release.version),
            Ok((_, None)) => (false, "no-releases".to_string()),
            Err(_) => (false, "fetch-error".to_string()),
        };

        let result = serde_json::json!({
            "project_version": project_version,
            "latest_version": latest_version,
            "update_available": update_available
        });
        println!("{}", serde_json::to_string(&result)?);
    }

    Ok(())
}

pub fn validate(all: bool, schema_type: Option<&str>, strict: bool) -> Result<()> {
    check_rotd_initialized()?;

    let mut report = ValidationReport {
        overall_status: "passed".to_string(),
        reports: std::collections::HashMap::new(),
        timestamp: Utc::now(),
    };

    let mut total_errors = 0;

    if all || schema_type.is_none() {
        // Validate tasks.jsonl
        match validate_tasks_jsonl(strict) {
            Ok(result) => {
                report.reports.insert("tasks".to_string(), result);
            }
            Err(_) => {
                let result = ValidationResult {
                    status: "failed".to_string(),
                    errors: vec!["Failed to read tasks.jsonl".to_string()],
                    warnings: vec![],
                    items_checked: 0,
                };
                total_errors += 1;
                report.reports.insert("tasks".to_string(), result);
            }
        }

        // Validate other schemas if they exist
        if crate::common::rotd_path().join("pss_scores.jsonl").exists() {
            let result = ValidationResult {
                status: "passed".to_string(),
                errors: vec![],
                warnings: vec![],
                items_checked: 1,
            };
            report.reports.insert("pss_scores".to_string(), result);
        }
    } else if let Some(schema) = schema_type {
        match schema {
            "tasks" => match validate_tasks_jsonl(strict) {
                Ok(result) => {
                    report.reports.insert("tasks".to_string(), result);
                }
                Err(_) => {
                    let result = ValidationResult {
                        status: "failed".to_string(),
                        errors: vec!["Failed to read tasks.jsonl".to_string()],
                        warnings: vec![],
                        items_checked: 0,
                    };
                    total_errors += 1;
                    report.reports.insert("tasks".to_string(), result);
                }
            },
            _ => {
                let result = ValidationResult {
                    status: "unknown".to_string(),
                    errors: vec![format!("Unknown schema type: {}", schema)],
                    warnings: vec![],
                    items_checked: 0,
                };
                total_errors += 1;
                report.reports.insert(schema.to_string(), result);
            }
        }
    }

    // Count total errors across all reports
    for result in report.reports.values() {
        total_errors += result.errors.len();
    }

    if total_errors > 0 {
        report.overall_status = "failed".to_string();
    }

    println!("{}", serde_json::to_string(&report)?);
    Ok(())
}

// Helper function for validation
pub fn validate_tasks_jsonl(strict: bool) -> Result<ValidationResult> {
    let tasks = read_jsonl::<TaskEntry>(&crate::common::tasks_path())?;

    let mut errors = Vec::new();
    let warnings = Vec::new();

    for (i, task) in tasks.iter().enumerate() {
        if let Err(e) = task.validate() {
            errors.push(format!("Line {}: {}", i + 1, e));
        }

        // Check for new priority field in strict mode
        if strict && task.priority.is_none() {
            errors.push(format!(
                "Line {}: Missing priority field (required in v1.2.1+)",
                i + 1
            ));
        }

        // Check for priority_score validation
        if let Some(score) = task.priority_score {
            if !(0.0..=100.0).contains(&score) {
                errors.push(format!(
                    "Line {}: priority_score must be between 0-100, got {}",
                    i + 1,
                    score
                ));
            }
        }
    }

    let status = if errors.is_empty() {
        "passed"
    } else {
        "failed"
    };

    Ok(ValidationResult {
        status: status.to_string(),
        errors,
        warnings,
        items_checked: tasks.len() as u32,
    })
}

/// Check for Buckle Mode trigger conditions (agent mode)
pub fn check_buckle_trigger() -> Result<()> {
    check_rotd_initialized()?;

    let triggered = false;
    let reasons: Vec<String> = Vec::new();

    // Check for compilation errors
    // Implementation would check cargo/npm output for error count

    // Check task.jsonl integrity
    // Implementation would verify task.jsonl status is consistent

    // Check test summaries
    // Implementation would verify test summaries exist for completed tasks

    // Check session state
    // Implementation would verify session_state.json is up to date

    // Return JSON result
    let result = json!({
        "triggered": triggered,
        "reasons": reasons,
        "recommendation": if triggered { "Enter Buckle Mode" } else { "No action needed" }
    });

    println!("{}", serde_json::to_string(&result)?);

    Ok(())
}

/// Enter Buckle Mode for a specific task (agent mode)
pub fn enter_buckle_mode(task_id: &str) -> Result<()> {
    check_rotd_initialized()?;

    // Check if already in Buckle Mode
    let buckle_state_path = crate::common::rotd_path().join("buckle_state.json");
    if buckle_state_path.exists() {
        let state: BuckleModeState =
            serde_json::from_str(&std::fs::read_to_string(&buckle_state_path)?).map_err(|e| {
                anyhow::anyhow!("{{\"error\":\"invalid_json\",\"message\":\"{}\"}}", e)
            })?;

        if state.active {
            let result = json!({
                "status": "error",
                "message": format!("Already in Buckle Mode for task: {}", state.task_id.clone().unwrap_or_default()),
                "current_task": state.task_id
            });
            println!("{}", serde_json::to_string(&result)?);
            return Ok(());
        }
    }

    // Create Buckle Mode state
    let state = BuckleModeState {
        active: true,
        task_id: Some(task_id.to_string()),
        entered_at: chrono::Utc::now().to_rfc3339(),
        compilation_fixed: false,
        artifacts_fixed: false,
        exit_criteria_met: false,
    };

    // Save state
    std::fs::write(buckle_state_path, serde_json::to_string_pretty(&state)?)?;

    // Log to audit log
    audit::log_entry(
        task_id,
        "audit.buckle.trigger.001",
        "critical",
        "Entered Buckle Mode manually",
    )?;

    // Return JSON result with diagnostics
    let diagnostics = diagnose_buckle_mode_json()?;
    let result = json!({
        "status": "success",
        "message": "Entered Buckle Mode successfully",
        "task_id": task_id,
        "diagnostics": diagnostics
    });

    println!("{}", serde_json::to_string(&result)?);

    Ok(())
}

/// Generate diagnostic report for Buckle Mode (agent mode)
pub fn diagnose_buckle_mode_json() -> Result<Value> {
    check_rotd_initialized()?;

    // Check Buckle Mode state
    let buckle_state_path = crate::common::rotd_path().join("buckle_state.json");
    if !buckle_state_path.exists() {
        return Ok(json!({
            "status": "error",
            "message": "Not in Buckle Mode"
        }));
    }

    let state: BuckleModeState =
        serde_json::from_str(&std::fs::read_to_string(&buckle_state_path)?)?;
    if !state.active {
        return Ok(json!({
            "status": "error",
            "message": "Not in Buckle Mode"
        }));
    }

    let task_id = state.task_id.unwrap_or_default();

    // Implementation would collect diagnostics

    let diagnostics = json!({
        "task_id": task_id,
        "compilation": {
            "status": "unknown",
            "errors": 0
        },
        "tests": {
            "status": "unknown",
            "total": 0,
            "passed": 0
        },
        "artifacts": {
            "status": "unknown",
            "missing": []
        },
        "task_tracking": {
            "status": "unknown",
            "issues": []
        },
        "exit_criteria": {
            "compilation_fixed": state.compilation_fixed,
            "artifacts_fixed": state.artifacts_fixed,
            "exit_criteria_met": state.exit_criteria_met,
            "can_exit": state.exit_criteria_met
        }
    });

    Ok(diagnostics)
}

/// Diagnose Buckle Mode status (agent mode)
pub fn diagnose_buckle_mode() -> Result<()> {
    let diagnostics = diagnose_buckle_mode_json()?;
    println!("{}", serde_json::to_string(&diagnostics)?);
    Ok(())
}

/// Fix compilation errors (agent mode)
pub fn fix_compilation() -> Result<()> {
    check_rotd_initialized()?;

    // Check Buckle Mode state
    let buckle_state_path = crate::common::rotd_path().join("buckle_state.json");
    if !buckle_state_path.exists() {
        let result = json!({
            "status": "error",
            "message": "Not in Buckle Mode"
        });
        println!("{}", serde_json::to_string(&result)?);
        return Ok(());
    }

    let mut state: BuckleModeState =
        serde_json::from_str(&std::fs::read_to_string(&buckle_state_path)?)?;
    if !state.active {
        let result = json!({
            "status": "error",
            "message": "Not in Buckle Mode"
        });
        println!("{}", serde_json::to_string(&result)?);
        return Ok(());
    }

    let unknown = "unknown".to_string();
    let task_id = state.task_id.as_ref().unwrap_or(&unknown);

    // Implementation would attempt to fix compilation errors

    // Update state
    state.compilation_fixed = true;
    std::fs::write(buckle_state_path, serde_json::to_string_pretty(&state)?)?;

    // Return JSON result
    let result = json!({
        "status": "success",
        "message": "Compilation fixes applied",
        "task_id": task_id,
        "next_step": "fix-artifacts"
    });

    println!("{}", serde_json::to_string(&result)?);

    Ok(())
}

/// Fix artifacts (agent mode)
pub fn fix_artifacts() -> Result<()> {
    check_rotd_initialized()?;

    // Check Buckle Mode state
    let buckle_state_path = crate::common::rotd_path().join("buckle_state.json");
    if !buckle_state_path.exists() {
        let result = json!({
            "status": "error",
            "message": "Not in Buckle Mode"
        });
        println!("{}", serde_json::to_string(&result)?);
        return Ok(());
    }

    let mut state: BuckleModeState =
        serde_json::from_str(&std::fs::read_to_string(&buckle_state_path)?)?;
    if !state.active {
        let result = json!({
            "status": "error",
            "message": "Not in Buckle Mode"
        });
        println!("{}", serde_json::to_string(&result)?);
        return Ok(());
    }

    let unknown = "unknown".to_string();
    let task_id = state.task_id.as_ref().unwrap_or(&unknown);

    // Implementation would attempt to fix artifacts

    // Update state
    state.artifacts_fixed = true;
    std::fs::write(buckle_state_path, serde_json::to_string_pretty(&state)?)?;

    // Return JSON result
    let result = json!({
        "status": "success",
        "message": "Artifact fixes applied",
        "task_id": task_id,
        "next_step": "check-exit"
    });

    println!("{}", serde_json::to_string(&result)?);

    Ok(())
}

/// Check exit criteria (agent mode)
pub fn check_exit_criteria() -> Result<()> {
    check_rotd_initialized()?;

    // Check Buckle Mode state
    let buckle_state_path = crate::common::rotd_path().join("buckle_state.json");
    if !buckle_state_path.exists() {
        let result = json!({
            "status": "error",
            "message": "Not in Buckle Mode"
        });
        println!("{}", serde_json::to_string(&result)?);
        return Ok(());
    }

    let mut state: BuckleModeState =
        serde_json::from_str(&std::fs::read_to_string(&buckle_state_path)?)?;
    if !state.active {
        let result = json!({
            "status": "error",
            "message": "Not in Buckle Mode"
        });
        println!("{}", serde_json::to_string(&result)?);
        return Ok(());
    }

    let unknown = "unknown".to_string();
    let task_id = state.task_id.as_ref().unwrap_or(&unknown);

    // Implementation would check all exit criteria

    // Update state
    state.exit_criteria_met = true;
    std::fs::write(buckle_state_path, serde_json::to_string_pretty(&state)?)?;

    // Return JSON result
    let result = json!({
        "status": "success",
        "message": "All exit criteria met",
        "task_id": task_id,
        "can_exit": true,
        "next_step": "exit"
    });

    println!("{}", serde_json::to_string(&result)?);

    Ok(())
}

/// Exit Buckle Mode (agent mode)
pub fn exit_buckle_mode() -> Result<()> {
    check_rotd_initialized()?;

    // Check Buckle Mode state
    let buckle_state_path = crate::common::rotd_path().join("buckle_state.json");
    if !buckle_state_path.exists() {
        let result = json!({
            "status": "error",
            "message": "Not in Buckle Mode"
        });
        println!("{}", serde_json::to_string(&result)?);
        return Ok(());
    }

    let state: BuckleModeState =
        serde_json::from_str(&std::fs::read_to_string(&buckle_state_path)?)?;
    if !state.active {
        let result = json!({
            "status": "error",
            "message": "Not in Buckle Mode"
        });
        println!("{}", serde_json::to_string(&result)?);
        return Ok(());
    }

    let unknown = "unknown".to_string();
    let task_id = state.task_id.as_ref().unwrap_or(&unknown);

    // Check if exit criteria are met
    if !state.exit_criteria_met {
        let result = json!({
            "status": "error",
            "message": "Exit criteria not met",
            "task_id": task_id
        });
        println!("{}", serde_json::to_string(&result)?);
        return Ok(());
    }

    // Remove Buckle Mode state
    std::fs::remove_file(buckle_state_path)?;

    // Log to audit log
    audit::log_entry(
        task_id,
        "audit.buckle.exit",
        "info",
        "Exited Buckle Mode successfully",
    )?;

    // Return JSON result
    let result = json!({
        "status": "success",
        "message": "Exited Buckle Mode successfully",
        "task_id": task_id
    });

    println!("{}", serde_json::to_string(&result)?);

    Ok(())
}
